# 查找

## 哈希表

### 散列函数

**散列函数**（Hash function），又称为哈希函数，是将关键字映射到存储地址的函数，记为`hash(key)=Addr`。设计散列函数时需要遵循以下2个原则。

1. 散列函数尽可能简单，能够快速计算关键字的散列地址。
2. 散列函数映射的地址应均匀分布整个地址空间，避免聚集，以减少冲突。

散列函数设计原则的4字箴言：**简单**、**均匀**。

#### 常见的散列函数：

1、**直接定址法**

直接取关键字的某个线性函数作为散列函数：$hash(key)=a*key+b$

其中，`a`、`b`为常数。

**适用场景：**事先知道关键字，关键字集合不是很大且连续性较好。关键字如果不连续，则有大量空位，造成空间浪费。

2、**除留余数法**

除留余数法是一种最简单和常用的构造散列函数的方法，并且不需要求事先知道关键字的分布。假定散列表的表长为`m`，取一个不大于表长的最大素数p，则设计散列函数为：$hash(key)= key%p$

无论如何设计散列函数，都无法避免冲突问题。发生冲突时，需要进行冲突处理。冲突处理方法分为3种：

**开放地址法、链地址法、建立公共溢出区**。

**1．开放地址法**

开放地址法是在线性存储空间上的解决方案，称为闭散列。发生冲突时，采用冲突处理方法在线性存储空间上探测其他位置。$hash'(key)=(hash(key)+d_i)%*m$

其中，$hash(key)$为原散列函数，$hash'(key)$为探测函数，$d_i$为增量序列，$m$为表长。

根据增量序列的不同，开放地址法又分为**线性探测法、二次探测法、随机探测法、再散列法。**

1. 线性探测法

线性探测法是最简单的开放地址法，线性探测的增量序列：$d_i=1, …, m−1$

例如，一组关键字(14, 36, 42, 38, 40, 15, 19, 12, 51, 65, 34, 25)，若表长为15，散列函数为$hash(key)=key%13$，采用线性探测法处理冲突，构造该散列表。

![image-20220829200241630](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208292002684.png)

**注意：**线性探测法很简单，只要有空间，就一定能够探测到位置。但是，在处理冲突的过程中，会出现非同义词之间对同一个散列地址争夺的现象，称为“**堆积**”。堆积大大地降低了查找效率。

**查找成功的平均查找长度：**

假设查找的概率均等（12个关键字，每个关键字查找概率为1/12），查找成功的平均查找长度等于所有关键字查找成功的比较次数$c_i$乘以查找概率$p_i$之和。

**查找失败的平均查找长度：**

本题中散列函数为$hash(key)=key%13$，计算得到的散列地址为0, 1, …, 12，一共有13种情况。那么就有13种失败的情况，查找失败的平均查找长度等于所有关键字查找失败的比较次数$c_i$乘以查找概率$p_i$之和。

如果关键字不相等，则继续按照线性探测向后查找，遇到空时，查找失败，计算比较次数。

散列函数为$hash(key)=key%13$，线性探测创建的散列表如图所示。计算查找成功和查找失败的平均查找长度。

![image-20220829200440922](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208292004982.png)

2. 二次探测法

二次探测法采用前后跳跃式探测的方法，发生冲突时，向后1位探测，向前1位探测，向后22位探测，向前22位探测……跳跃式探测，避免堆积。

二次探测的增量序列为如下。

$ d_i=1^2, −1^2, 2^2, −2^2, …, k^2, −k^2(k≤m/2)$

例如，一组关键字（14，36，42，38，40，15，19，12，51，65，34，25），若表长为15，散列函数为$hash(key)=key%13$，采用二次探测法处理冲突，构造该散列表。

![image-20220829200621940](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208292006988.png)

**注意：**二次探测法是跳跃式探测，效率较高，但是会出现明明有空间却探测不到的情况，因而存储失败，而线性探测只要有空间就一定能够探测成功。

**2．链地址法**

链地址法又称为拉链法。如果不同关键字通过散列函数映射到同一地址，这些关键字为同义词，将所有的同义词存储在一个线性链表中。查找、插入、删除操作主要在这个链表中进行，拉链法适用于经常进行插入、删除的情况。

例如，一组关键字（14, 36, 42, 38, 40, 15, 19, 12, 51, 65, 34, 25），若表长为15，散列函数为$hash(key)=key%13$，采用链地址法处理冲突，构造该散列表，计算查找成功和查找失败的平均查找长度。

![image-20220829200707808](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208292007867.png)

## KMP算法

假设有两个串`S`，`T`，设`S`为主串，也称正文串，`T`为子串，也称为模式，在主串`S`中查找与模式`T`相匹配的子串，如果查找成功，返回匹配的子串第一个字符在主串中的位置。

最笨的办法就是穷举所有`S`的所有子串，判断是否与`T`匹配。该算法称为BF(Brute Force)算法，Brute Force的意思是蛮力，暴力穷举。

Knuth、Morris和Pratt提出了著名的模式匹配算法——**KMP算法**。

KMP算法的特点是`i`不回退，如果`S[i]=T[j]`时，则`i++`，`j++`，继续比较；如果`S[i]≠T[j]`，`j`回退到`next[j]`，重新开始比较。

算法关键是计算`next[]`数组。

`i`指向的字符前面的两个字符和`T`串中`j`指向的字符前面两个字符一模一样，因为它们一直相等，才会`i++`，`j++`，走到当前的位置。只需要在`T`串本身比较就可以了。

![image-20220830182726802](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208301827858.png)

假设`T`串中当前`j`指向的字符前面的所有字符为`T'`，则只需比较`T'`的前缀和`T'`的后缀即可，如下图所示。

![image-20220830182835258](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208301828296.png)

`next[j]`表示`S[i]≠T[j] `时，`j`需要回退的位置，$T'="t_0*t_1…*t_{j-1}"$

纯手工计算$T="abaabe"$的`next[]`数组

![image-20220830183105884](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208301831917.png)

`next[j]`表示`S[i]≠T[j] `时，`j`需要回退的位置，$T'="t_0*t_1…*t_j-1"$

KMP的求解方法：假设已知`next[j]=k`

![image-20220830183250489](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208301832535.png)

![image-20220830183302901](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208301833942.png)

**算法分析**

- 时间复杂度：设`S`、`T`串的长度分别为`n`、`m`。KMP算法的特点是`i`不回退，当`S[i]≠T[j]`时，`j`回退到`next[j]`，重新开始比较。最坏情况下扫描整个`S`串，时间复杂度为$O(n)$。计算`next[]`数组需要扫描整个`T`串，时间复杂度为$O(m)$，总时间复杂度为$O(n+m)$。
- 空间复杂度：辅助数组`next[]`，空间复杂度为$O(m)$。