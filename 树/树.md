# 树

树是`n`（n≥0）个节点的有限集合，当n=0时，为空树。任意一棵非空树，满足：

1. 有且仅有一个被称为根的节点；

2. 除根节点外，其余节点可分为`m`个互不相交的有限集`T1, T2, …, Tm`，每一个集合本身又是一棵树，称为根的子树。

![image-20220721134453316](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211345378.png)

## 树的存储

树形结构是一对多的关系，除了树根，每个节点都有一个唯一的直接前驱（双亲）；除了叶子，每个节点都有一个或多个直接后继（孩子）。

那么如何将数据及它们之间的逻辑关系存储起来呢？

- 可以采用顺序存储和链式存储。

树的**顺序存储**分为双亲表示法、孩子表示法和双亲孩子表示法。

![image-20220721134658921](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211346954.png)

![image-20220721134707874](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211347932.png)

树的**链式存储**分为孩子链表表示法和孩子兄弟表示法。

![image-20220721134738396](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211347428.png)

![image-20220721134745470](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211347514.png)

![image-20220721134756964](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211347025.png)

孩子兄弟表示法的秘诀：长子当作左孩子，兄弟关系向右斜。

## 二叉树

二叉树（binary tree）是*n*（*n*≥0）个节点构成的集合，当*n*=0时，为空树。任意一棵非空二叉树，满足：

1. 有且仅有一个称为根的节点；

2. 除根节点以外，其余节点分为两个互不相交的子集*T*1和*T*2，分别称为*T*的左子树和右子树，且*T*1和*T*2本身都是二叉树。

![image-20220721134540854](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211345902.png)

### 树转换二叉树

树转换为二叉树的秘诀：长子当作左孩子，兄弟关系向右斜。

![image-20220721134850010](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211348064.png)

### 二叉树还原树

二叉树还原树为的秘诀：左孩子为长子，右斜线为兄弟。

![image-20220721135004542](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211350592.png)

### 森林转换二叉树

把森林中的每棵树的树根看作兄弟关系，把森林中的每一棵树转换成二叉树，然后把每棵树的根节点连接在右斜线上。

![image-20220721135025429](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211351083.png)

### 二叉树还原森林

二叉树还原森林为的秘诀：右斜线上每个节点为一棵树的根，将每棵二叉树转换为树。

![image-20220721135058255](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211350322.png)

## 二叉树的性质

**性质1：在二叉树的第`i`层上至多有$x^{i-1}$个节点。**

![image-20220721135659604](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211356655.png)

**性质2：深度为`k`的二叉树至多有$2^k−1$个节点。**

![image-20220721140155873](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211401924.png)

**性质3：对于任何一棵二叉树，若叶子数为$n_0$，度为2的节点数为$n_2$，则$n_0=n_2+1$。**

![image-20220721140307550](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211403597.png)

- **满二叉树**：一棵深度为$k$且有$2^k−1$个节点的二叉树。满二叉树每一层都“充满”了节点，达到最大节点数。

- **完全二叉树**：除了最后一层外，每一层都是满的（达到最大节点数），最后一层节点是从左向右出现的。

​    深度为*k*的完全二叉树，当且仅当其每一个节点都与深度为*k* 的满二叉树中编号1～n的节点一一对应。

**性质4：具有n个节点的完全二叉树的深度必为$\lfloor log_2n \rfloor+1$。**

![image-20220721140622413](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211406460.png)

$2^k−1≤n≤2^k−1$，右边放大后，$2^k−1≤n<2^k$，同时取对数，$k−1≤log_2n<k$，所以$k=\lfloor log2n\rfloor+1$。$\lfloor x \rfloor$表示小于x的最大整数。

**性质5：对于完全二叉树，若从上至下、从左至右编号，则编号为i的节点，其左孩子编号必为$2i$，其右孩子编号必为$2i +1$，其双亲的编号必为$i/2$。**

![image-20220721140919320](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211409356.png)

二叉树也可以采用顺序存储，按完全二叉树的节点层次编号，依次存放二叉树中的数据元素。

![image-20220721141036792](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211410837.png)

二叉树的链式存储：每个节点包含一个数据域，存储节点信息；还包含两个指针域，指向左右两个孩子。这种存储方式称为二叉链表。

```c++
typedef struct Bnode{/*定义二叉树存储结构*/
	ElemType data;
	struct Bnode *lchild,*rchild;
}Bnode,*Btree;

```

![image-20220721141203483](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211412519.png)

![image-20220721141210858](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207211412893.png)

## 二叉树遍历

二叉树的遍历是指按某条搜索路径访问二叉树中的每个节点一次且只有一次。

按照根、左子树和右子树的访问先后顺序不同，二叉树的遍历可以有6种方案：DLR、LDR、LRD、DRL、RDL、RLD。如果限定先左后右（先左子树后右子树），则只有前3种遍历方案：DLR、LDR、LRD。按照根的访问顺序不同，根在前面称为先序遍历（DLR），根在中间称为中序遍历（LDR），根在最后称为后序遍历（LRD）。

### 先序遍历

先序遍历是指先访问根，然后先序遍历左子树，再先序遍历右子树。

**算法步骤：**

如果二叉树为空，则空操作，否则：

1）访问根节点；

2）先序遍历左子树；

3）先序遍历右子树。

**先序遍历秘籍：**

访问根，先序遍历左子树，左子树为空或已遍历才可以遍历右子树。

对下面二叉树进行先序遍历：

![image-20220727071703631](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207271518830.png)

```c++
void preorder(Btree T){//先序遍历
    if(T){
       cout<<T->data<<"  ";
       preorder(T->lchild);
       preorder(T->rchild);
    }
}
```

### 中序遍历

中序遍历是指中序遍历左子树，然后访问根，再中序遍历右子树。

**算法步骤：**

如果二叉树为空，则空操作，否则：

1）中序遍历左子树；

2）访问根节点；

3）中序遍历右子树。

**中序遍历秘籍：**中序遍历左子树，左子树为空或已遍历才可以访问根，中序遍历右子树。

对下面二叉树进行中序遍历：

![image-20220727071703631](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207271520797.png)

```c++
void inorder(Btree T){//中序遍历
    if(T){
       inorder(T->lchild);
       cout<<T->data<<"  ";
       inorder(T->rchild);
    }
}
```

### 后序遍历

后序遍历是指后序遍历左子树，后序遍历右子树，然后访问根。

**算法步骤：**

如果二叉树为空，则空操作，否则：

1）后序遍历左子树；

2）后序遍历右子树；

3）访问根节点。

**后序遍历秘籍：**后序遍历左子树，后序遍历右子树，左子树、右子树为空或已遍历才可以访问根。

对下面二叉树进行后序遍历：

![image-20220727152049427](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207271520468.png)

```c++
void posorder(Btree T){//后序遍历
    if(T){
       posorder(T->lchild);
       posorder(T->rchild);
       cout<<T->data<<"  ";
    }
}
```

### 投影法求遍历序列

中序遍历就像在无风的情况下，遍历顺序为左子树、根、右子树，太阳直射，将所有的节点投影到地上。

![image-20220727152125349](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207271521409.png)

先序遍历就像在左边大风的情况下，将二叉树的树枝刮向右方，且顺序为根、左子树、右子树，太阳直射，将所有的节点投影到地上。

![image-20220727152140697](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207271521750.png)

后序遍历就像在右边大风的情况下，将二叉树的树枝刮向左方，且顺序为左子树、右子树、根，太阳直射，将所有的节点投影到地上。

![image-20220727152150510](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207271521564.png)

### 层次遍历

层次遍历，即按照层次的顺序从左向右进行遍历。

**层次遍历秘籍：**首先遍历第1层，然后第2层……同一层按照从左向右的顺序访问，直到最后一层。

![image-20220727152214712](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207271522753.png)

通过观察可以发现，先被访问的节点，其孩子也先被访问，先来先服务，因此可以用队列实现。使用队列对下面二叉树进行层次遍历。

```c++
bool leveltraverse(Btree T){
    Btree p;
    if(!T)
        return false;
    queue<Btree>Q; //创建一个队列，指针类型
    Q.push(T); //根指针入队
    while(!Q.empty()){ //如果队列不空
        p=Q.front();//取出队头元素
        Q.pop(); //队头元素出队
        cout<<p->data<<"  ";
        if(p->lchild)
            Q.push(p->lchild); //左孩子指针入队
        if(p->rchild)
            Q.push(p->rchild); //右孩子指针入队
    }
    return true;
}
```

**算法复杂度分析**

- 时间复杂度：O(n)
- 空间复杂度：O(n)

## 二叉树创建

### 二叉树的存储

二叉树也可以采用**顺序存储**，按完全二叉树的节点层次编号，依次存放二叉树中的数据元素。

![image-20220727152415342](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207271524391.png)

![image-20220727152423749](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207271524781.png)

**二叉树的链式存储**：每个节点包含一个数据域，存储节点信息；还包含两个指针域，指向左右两个孩子。这种存储方式称为二叉链表。

<img src="https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207271525768.png" alt="image-20220727152512733" style="zoom:50%;" />

```c++
typedef struct Bnode{/*定义二叉树存储结构*/
	char data;
	struct Bnode *lchild,*rchild;
}Bnode,*Btree;
```

`*lchild`：左孩子指针

`*rchild`：右孩子指针

![image-20220727152722173](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207271527217.png)

![image-20220727152735870](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207271527913.png)

补空法指如果左子树或右子树为空，则用特殊字符补空，例如“#”。然后根据先序遍历序列递归创建二叉树。

二叉树补空后的先序遍历结果为：ABD##E##CF#G###。

二叉树的创建过程：

```c++
void createtree(Btree &T){	/*创建二叉树函数*/
    //按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T
	char ch;
	cin>>ch;
	if(ch=='#')
        T=NULL;			//递归结束，建空树
	else{
		T=new Bnode;
		T->data=ch;					//生成根结点
		createtree(T->lchild);	//递归创建左子树
		createtree(T->rchild);	//递归创建右子树
	}
}
```

**算法复杂度分析**

- 时间复杂度：O(n)
- 空间复杂度：O(n)

## 遍历序列还原树

根据遍历序列可以还原树，包括3种

- 还原二叉树
- 还原树
- 还原森林

### 还原二叉树

由二叉树的先序序列和中序序列，或者中序序列和后序序列，可以唯一地还原一棵二叉树。

> 由二叉树的先序序列和后序序列不能唯一地还原一棵二叉树。

#### 先序序列和中序序列还原二叉树。

**算法步骤:**

1）先序序列的第一个字符为根。

2）在中序序列中，以根为中心划分左右子树。

3）还原左右子树。

![image-20220727153013705](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207271530759.png)

代码演示：

函数设置三个参数： pre，mid，len。

pre、mid为指针类型，分别指向先序、中序序列的首地址；len为序列的长度。

![image-20220727153147900](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202207271531953.png)

```c++
Btree pre_mid_createbtree(char *pre,char *mid,int len){ //先序、中序还原二叉树
    if(len==0)
        return NULL;
    char ch=pre[0]; //先序中的第1个节点为根
    int index=0;
    while(mid[index]!=ch){//在中序中找到根的位置，根的左边为该节点的左子树，右边为右子树
        index++;
    }
    Btree T=new Bnode;//创建根节点
    T->data=ch;
    T->lchild=pre_mid_createbtree(pre+1,mid,index);//创建左子树
    T->rchild=pre_mid_createbtree(pre+index+1,mid+index+1,len-index-1);//创建右子树
    return T;
}

Btree pro_mid_createbtree(char *last,char *mid,int len){//后序、中序还原二叉树
    if(len==0)
       return NULL;
    char ch=last[len-1]; //后序中的最后1个节点为根 
    int index=0;
    while(mid[index]!=ch)//在中序中找到根的位置，根的左边为该节点的左子树，右边为右子树
       index++;
    Btree T=new Bnode;//创建根节点 
    T->data=ch;
    T->lchild=pro_mid_createbtree(last,mid,index);//创建左子树
    T->rchild=pro_mid_createbtree(last+index,mid+index+1,len-index-1);//创建右子树
    return T;
}

```

先序遍历和中序遍历还原二叉树秘籍：先序找根，中序分左右。

后序遍历和中序遍历还原二叉树秘籍：后序找根，中序分左右。

### 还原树

树的先根遍历和后根遍历与其对应二叉树的先序遍历和中序遍历相同，先根据对应关系还原为二叉树，再把二叉树转换为树。

### 还原森林

森林的先序遍历和中序遍历与其对应二叉树的先序遍历和中序遍历相同，先根据对应关系还原为二叉树，再把二叉树转换为森林。