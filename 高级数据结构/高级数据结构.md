# 高级数据结构

## 并查集

若某个家族人员过于庞大，要判断两个人是否是亲戚，确实很不容易。根据某个亲戚关系图，现在任意给出两个人，判断其是否具有亲戚关系。规定：*x*和*y*是亲戚，*y*和*z*是亲戚，那么*x*和*z*也是亲戚。如果*x*和*y*是亲戚，那么*x*的亲戚都是*y*的亲戚，*y*的亲戚也都是*x*的亲戚。

那么如何快速判断两个人是否是亲戚呢？

可以使用并查集快速判断两人是否有亲戚关系。

并查集是一种树形数据结构，用于处理一些不相交集合的合并及查询问题。创建并查集只需要三个步骤。

**算法步骤：**

1. 初始化。把每个点所在集合初始化为其自身。
2. 查找。查找两个元素所在的集合，即找祖宗。
3. 合并。如果两个元素的集合号不同，将两个元素合并为一个集合。

**注意：**

查找时，递归找祖宗，祖宗集合号等于本身时停止。回归时，把查找路径上的所有节点统一为祖宗的集合号。

合并时，只需要把一个元素的祖宗集合号改为另一个元素的祖宗集合号。“**擒贼先擒王**”，只改祖宗即可！

假设现在有7个人，通过输入亲戚关系（9个亲戚关系分别为：2—7, 4—5, 3—7, 4—7, 3—4, 5—7, 5—6, 2—3, 1—2），创建并查集。

**算法时间复杂度分析**

- 初始化：$O(n)$
- 查找：$O(logn)$
- 合并：$O(1)$

## 优先队列

  priority_queue是一个优先队列，优先级高的最先出队，默认最大值优先。内部实现为堆，因此出队和入队的时间复杂度均为$*O*(log*n*)$。可以自定义优先级控制出队顺序，如果是数值，也可以采用加负号的方式实现最小值优先，优先队列不支持删除堆中指定元素，只可以删除堆顶，如果需要删除，可以采用懒操作。需要引入头文件`#include<queue>`。成员函数：

` push(x)`：入队；

` pop()`：出队；

` top()`：取队头元素；

` size()`：返回队中元素个数；

` empty()`：判队空，若为空返回true；

优先队列，其构造及具体实现先不用深究，只需要了解其特性：

`priority_queue<int, vector<int>, cmp >que;`

其中，第一个参数为数据类型，第二个参数为容器类型，第三个参数为比较函数。后两个参数根据需要也可以省略。

优先队列最常用的用法：

```c
priority_queue<int> que; //参数为数据类型，默认优先级（最大值优先）
```

如果要把元素从小到大输出怎么办呢？

有4种方法可以实现优先级控制：

- 使用C++自带的库函数`<functional>`
- 自定义优先级①
- 自定义优先级②
- 自定义优先级③

方法1：使用C++自带的库函数`<functional>`，引用`#include<functional>`

```c
equal_to<Type>   //等于

not_equal_to<Type> //不等于

greater<Type>   //大于

greater_equal<Type> //大于等于

less<Type>    //小于

less_equal<Type>  //小于等于

priority_queue<int,vector<int>, less<int> >que1; //最大值优先 

//注意“>>”会被认为错误，“>>”是右移运算符，用空格号隔开

priority_queue<int,vector<int>, greater<int> >que2;//最小值优先 
```

方法2：自定义优先级① ， 队列元素为数值型

```c
struct cmp1{ 
    bool operator ()(int &a,int &b){ 
        return a<b;//最大值优先，a>b表示最小值优先 
   } 
}; 

//创建优先队列：
priority_queue<int,vector<int>,cmp1>que3;//最大值优先 
```

方法3：自定义优先级 ②，队列元素为结构体型 

```c
struct node1{  
    int x,y;  //结构体中的成员
    bool operator < (const node1 &a) const {  
         return x<a.x;//最大值优先，x>a.x;表示最小值优先 
    }  
};

//创建优先队列：
priority_queue<node1>que5; //使用时要把数据定义为node1类型
```

方法4：自定义优先级 ③，队列元素为结构体型 

```c
struct node3{  
      int x,y;  //结构体中的成员
};  
bool operator <(const node3 &a, const node3 &b) {//在结构体外面定义
      return a.x<b.x; //按成员x最大值优先 
}

//创建优先队列：
priority_queue<node3>que7; //使用时要把数据定义为node3类型
```

**算法时间复杂度分析**

- 入队：$O(logn)$
- 出队：$O(logn)$

## 倍增

任意整数均可被表示成若干个2的次幂项之和。例如整数5，其二进制表示为101，该二进制数从右向左第0、2位均为1，则5=22+20；整数26，其二进制表示为11010，该二进制数从右向左第1、3、4位均为1，则26=24+23+21。也就是说，2的次幂项可被拼成任一需要的值。

 倍增，顾名思义就是成倍增加。若问题的状态空间特别大，则一步步递推的算法复杂度太高，可以通过倍增思想，只考察2的整数次幂位置，快速缩小求解范围，直到找到解。

![image-20220907181756645](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209071817699.png)

## ST表

ST（Sparse Table，稀疏表）算法采用了倍增思想，在$O(nlogn)$时间构造一个二维表之后，可以在$O(1)$时间在线查询$[l, r]$区间的最值，有效解决在线RMQ（Range Minimum/Maximum Query，区间最值查询）问题。

 如何实现呢？设$F[i, j]$表示$[i, i+2^j-1]$区间的最值，区间长度为$2j$。

![image-20220907181820234](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209071818274.png)

 根据倍增思想，长度为$2^j$的区间可被分成两个长度为$2^j-1$的子区间，然后求两个子区间的最值即可。递推公式：$F[i, j]=max(F[i, j-1], F[i+2^{j-1}, j-1])$。

![image-20220907181836251](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209071818314.png)

### ST表创建

若$F[i, j]$表示$[i, i+2^j-1]$区间的最值，区间长度为$2^j$，则$i$和$j$的取值范围是多少呢？

若数组的长度为$n$，最大区间长度$2^k≤n<2^{k+1}$，则$k=⌊log_2n⌋$，比如$n=8$时$k=3$，$n=10$时$k=3$。在程序中，$k=log_2(n)$，也可用通用表达方式$k=log(n)/log(2)$，$log()$表示以$e$为底的自然对数。

例如，有10个元素$a[1..10]={5,3,7,2,12,1,6,4, 8,15}$，创建查询最大值的ST表。

$F[i, j]$表示$[i, i+2^j-1]$区间的最值，区间长度为$2^j$。

![image-20220907182321690](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209071823748.png)

### ST表查询

若查询$[l,r]$区间的最值，则首先计算$k$值，和前面的计算方法相同，区间长度为$r-l+1，2^k≤r-l+1<2^{k+1}$，因此$k=log_2(r-l+1) $。

若查询区间的长度大于或等于$2^k$且小于$2^{k+1}$，则根据倍增思想，可以将查询区间分为两个查询区间，取两个区间的最值即可。两个区间分别为从$l$向后的$2^k$个数及从$r$向前的$2^k$个数，这两个区间可能有重叠，但对求最值没有影响。

**算法时间复杂度分析**

- ST创建：$O(nlogn)$
- ST查询：$O(1)$

## RMQ

RMQ（区间最值查询）问题有多种解决方法，用线段树和ST解决RMQ问题的对比如下：

- 线段树预处理的时间为$O(nlogn)$，查询的时间为$O(logn)$，支持在线修改；

- ST预处理的时间为$O(nlogn)$，查询的时间为$O(1)$，不支持在线修改。

## 最近公共祖先

最近公共祖先（Lowest Common Ancestors，LCA）指有根树中距离两个节点最近的公共祖先。祖先指从当前节点到树根路径上的所有节点。

` u`和`v`的公共祖先指一个节点既是`u`的祖先，又是`v`的祖先。`u`和`v`的最近公共祖先指距离`u`和`v`最近的公共祖先。若`v`是`u`的祖先，则`u`和`v`的最近公共祖先是`v`。

![image-20220908192543673](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209081925733.png)

可以使用LCA求解树上任意两点之间的距离。求`u`和`v`之间的距离时，若`u`和`v`的最近公共祖先为`lca`，则`u`和`v`之间的距离为`u`到树根的距离加上`v`到树根的距离减去2倍的`lca`到树根的距离：`dist[u]+dist[v]-2*dist[lca]`。

![image-20220908192606737](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209081926791.png)

 求解LCA的方法有很多，包括暴力搜索法、树上倍增法、在线RMQ算法、离线Tarjan算法和树链剖分。

 **在线算法：**以序列化方式一个一个地处理输入，也就是说，在开始时并不需要知道所有输入，在解决一个问题后立即输出结果。

 **离线算法：**在开始时已知问题的所有输入数据，可以一次性回答所有问题。

暴力搜索法有两种：向上标记法和同步前进法。

### 向上标记法

从`u`向上一直到根节点，标记所有经过的节点；若`v`已被标记，则`v`节点为`LCA(u, v)`；否则`v`也向上走，第1次遇到已标记的节点时，该节点为`LCA(u, v)`。

![image-20220908192840446](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209081928498.png)

### 同步前进法

将`u`、`v`中较深的节点向上走到和深度较浅的节点同一深度，然后两个节点一起向上走，直到走到同一个节点，该节点就是`u`、`v`的最近公共祖先，记作`LCA(u,v)`。若较深的节点`u`到达`v`的同一深度时，那个节点正好是`v`，则`v`节点为`LCA(u,v)`。

![image-20220908192926097](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209081929152.png)

树上倍增法不仅可以解决LCA问题，还可以解决很多其他问题，掌握树上倍增法是很有必要的。

`F[i, j]`表示`i`的$2^j$辈祖先，即`i`节点向根节点走$2^j$步到达的节点。

![image-20220908193034763](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209081930809.png)

和前面暴力搜索中的同步前进法一样，先让深度大的节点`y`向上走到与`x`同一深度，然后`x`、`y`一起向上走。和暴力搜索不同的是，向上走是按照倍增思想走的，不是一步一步向上走的，因此速度较快。

![image-20220908193121039](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209081931081.png)

**算法时间复杂度分析**

- ST创建：$O(nlogn)$
- LCA查询：$O(logn)$

## 树状数组

树状数组引入了分级管理制度，设置一个管理小组，每个管理员管理一个或多个连续的元素。例如，数列有9个元素，分别用`a[1],a[2],…,a[9]`存储，管理数组为`c[]`。管理数组`c[]`是树状的，因此称为**树状数组**。

![image-20220909184347645](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209091843009.png)

树状数组，又称为二进制索引树（Binary Indexed Trees），通过二进制分解划分区间。那么`c[i]`存储的是哪些值？

### 区间长度

若`i`的二进制表示末尾有`k`个连续的`0`，则`c[i]`存储的区间长度为`2^k`，从`a[i]`向前数`2^k`个元素，即`c[i]=a[i-2^k+1]+a[i-2^k+2]+…+a[i]`。

![image-20220909184506292](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209091845345.png)

区间长度就是`i`的二进制表示下最低位的1及它后面的0构成的数值。

例如`i=20`，其二进制表示为10100，末尾有2个0，区间长度为$2^2$，其实就是10100最低位的1及其后面的0构成的数值$(100)_2$ ，十进制为4。

在计算机中二进制数采用的是补码表示， `-i`的补码正好是`i`取反加1。

`c[i]`存储的区间长度：`lowbit(i)=(-i)&i`。

### 前驱和后继

直接前驱：`c[i]`的直接前驱为`c[i-lowbit(i)]`，即`c[i]`左侧紧邻的子树的根。

直接后继：`c[i]`的直接后继为`c[i+lowbit(i)]`，即`c[i]`的父节点。

前驱：`c[i]`左侧所有子树的根。

后继：`c[i]`的所有祖先。

![image-20220909184648344](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209091846409.png)

### 查询前缀和

前`i`个元素的前缀和`sum[i]`等于`c[i]`加上`c[i]`的前驱。

`sum[7]`等于`c[7]`加上`c[7]`的前驱，`sum[7]=c[7]+c[6]+c[4]`。

![image-20220909184731316](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209091847389.png)

### 点更新

若对`a[i]`进行修改，令`a[i]`加上一个数`z`，则只需更新`c[i]`及其后继（祖先），即令这些节点都加上`z`即可，无需修改其他节点。

例如，修改`a[5]`，令其加2。

只需`c[5]+2`，然后`c[5]`的后继分别加2，

即`c[6]+2`、`c[8]+2`。

![image-20220909184815260](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209091848323.png)

### 查询区间和

若求区间和值`a[i]+a[i+1]+…+a[j]`，则求解前`j`个元素的和值减去前`i-1`个元素的和值即可，即`sum[j]-sum[i-1]`。

**算法分析：**

点更新时，从叶子更新到树根，执行的次数不超过树的高度$O(logn)$。

前缀和查询时，从当前结点一直查找前驱，前驱的个数不超过$O(logn)$。

![image-20220909184915576](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209091849638.png)

### 树状数组的局限性

树状数组主要用于查询前缀和、区间和及点更新，对点查询、区间更新效率较低。

**前缀和**：求`a[1]...a[i]`的前缀和，普通数组$O(n)$，树状数组$O(logn)$。

**区间和**：求`a[i]...a[j]`的区间和，普通数组$O(n)$，树状数组$O(logn)$。

**点更新**：修改`a[i]`加上`z`，普通数组$O(1)$，树状数组$O(logn)$。

**点查询：**查找第`i`个元素，普通数组 $O(1)$，树状数组$O(logn)$ （求`sum[i]-sum[i-1]`）。

**区间更新**：区间`a[i]...a[j]`的所有元素加`z`，普通数组$O(n) $，树状数组 $O(nlogn) $。

**减法规则**：当问题满足减法规则时，例如求区间和`a[i]...a[j]`，则`sum(i,j)=sum[j]-sum[i-1]`。当问题不满足减法规则时，例如求区间`a[i]...a[j]`的最大值，则不可以用`a[1]...a[j]`的最大值减去`a[1]...a[i-1]`的最大值，此时可以用线段树解决。
