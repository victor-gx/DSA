# 高级数据结构

## 并查集

若某个家族人员过于庞大，要判断两个人是否是亲戚，确实很不容易。根据某个亲戚关系图，现在任意给出两个人，判断其是否具有亲戚关系。规定：*x*和*y*是亲戚，*y*和*z*是亲戚，那么*x*和*z*也是亲戚。如果*x*和*y*是亲戚，那么*x*的亲戚都是*y*的亲戚，*y*的亲戚也都是*x*的亲戚。

那么如何快速判断两个人是否是亲戚呢？

可以使用并查集快速判断两人是否有亲戚关系。

并查集是一种树形数据结构，用于处理一些不相交集合的合并及查询问题。创建并查集只需要三个步骤。

**算法步骤：**

1. 初始化。把每个点所在集合初始化为其自身。
2. 查找。查找两个元素所在的集合，即找祖宗。
3. 合并。如果两个元素的集合号不同，将两个元素合并为一个集合。

**注意：**

查找时，递归找祖宗，祖宗集合号等于本身时停止。回归时，把查找路径上的所有节点统一为祖宗的集合号。

合并时，只需要把一个元素的祖宗集合号改为另一个元素的祖宗集合号。“**擒贼先擒王**”，只改祖宗即可！

假设现在有7个人，通过输入亲戚关系（9个亲戚关系分别为：2—7, 4—5, 3—7, 4—7, 3—4, 5—7, 5—6, 2—3, 1—2），创建并查集。

**算法时间复杂度分析**

- 初始化：$O(n)$
- 查找：$O(logn)$
- 合并：$O(1)$

## 优先队列

  priority_queue是一个优先队列，优先级高的最先出队，默认最大值优先。内部实现为堆，因此出队和入队的时间复杂度均为$*O*(log*n*)$。可以自定义优先级控制出队顺序，如果是数值，也可以采用加负号的方式实现最小值优先，优先队列不支持删除堆中指定元素，只可以删除堆顶，如果需要删除，可以采用懒操作。需要引入头文件`#include<queue>`。成员函数：

` push(x)`：入队；

` pop()`：出队；

` top()`：取队头元素；

` size()`：返回队中元素个数；

` empty()`：判队空，若为空返回true；

优先队列，其构造及具体实现先不用深究，只需要了解其特性：

`priority_queue<int, vector<int>, cmp >que;`

其中，第一个参数为数据类型，第二个参数为容器类型，第三个参数为比较函数。后两个参数根据需要也可以省略。

优先队列最常用的用法：

```c
priority_queue<int> que; //参数为数据类型，默认优先级（最大值优先）
```

如果要把元素从小到大输出怎么办呢？

有4种方法可以实现优先级控制：

- 使用C++自带的库函数`<functional>`
- 自定义优先级①
- 自定义优先级②
- 自定义优先级③

方法1：使用C++自带的库函数`<functional>`，引用`#include<functional>`

```c
equal_to<Type>   //等于

not_equal_to<Type> //不等于

greater<Type>   //大于

greater_equal<Type> //大于等于

less<Type>    //小于

less_equal<Type>  //小于等于

priority_queue<int,vector<int>, less<int> >que1; //最大值优先 

//注意“>>”会被认为错误，“>>”是右移运算符，用空格号隔开

priority_queue<int,vector<int>, greater<int> >que2;//最小值优先 
```

方法2：自定义优先级① ， 队列元素为数值型

```c
struct cmp1{ 
    bool operator ()(int &a,int &b){ 
        return a<b;//最大值优先，a>b表示最小值优先 
   } 
}; 

//创建优先队列：
priority_queue<int,vector<int>,cmp1>que3;//最大值优先 
```

方法3：自定义优先级 ②，队列元素为结构体型 

```c
struct node1{  
    int x,y;  //结构体中的成员
    bool operator < (const node1 &a) const {  
         return x<a.x;//最大值优先，x>a.x;表示最小值优先 
    }  
};

//创建优先队列：
priority_queue<node1>que5; //使用时要把数据定义为node1类型
```

方法4：自定义优先级 ③，队列元素为结构体型 

```c
struct node3{  
      int x,y;  //结构体中的成员
};  
bool operator <(const node3 &a, const node3 &b) {//在结构体外面定义
      return a.x<b.x; //按成员x最大值优先 
}

//创建优先队列：
priority_queue<node3>que7; //使用时要把数据定义为node3类型
```

**算法时间复杂度分析**

- 入队：$O(logn)$
- 出队：$O(logn)$





