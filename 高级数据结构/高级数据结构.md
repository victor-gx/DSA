# 高级数据结构

## 并查集

若某个家族人员过于庞大，要判断两个人是否是亲戚，确实很不容易。根据某个亲戚关系图，现在任意给出两个人，判断其是否具有亲戚关系。规定：*x*和*y*是亲戚，*y*和*z*是亲戚，那么*x*和*z*也是亲戚。如果*x*和*y*是亲戚，那么*x*的亲戚都是*y*的亲戚，*y*的亲戚也都是*x*的亲戚。

那么如何快速判断两个人是否是亲戚呢？

可以使用并查集快速判断两人是否有亲戚关系。

并查集是一种树形数据结构，用于处理一些不相交集合的合并及查询问题。创建并查集只需要三个步骤。

**算法步骤：**

1. 初始化。把每个点所在集合初始化为其自身。
2. 查找。查找两个元素所在的集合，即找祖宗。
3. 合并。如果两个元素的集合号不同，将两个元素合并为一个集合。

**注意：**

查找时，递归找祖宗，祖宗集合号等于本身时停止。回归时，把查找路径上的所有节点统一为祖宗的集合号。

合并时，只需要把一个元素的祖宗集合号改为另一个元素的祖宗集合号。“**擒贼先擒王**”，只改祖宗即可！

假设现在有7个人，通过输入亲戚关系（9个亲戚关系分别为：2—7, 4—5, 3—7, 4—7, 3—4, 5—7, 5—6, 2—3, 1—2），创建并查集。

**算法时间复杂度分析**

- 初始化：$O(n)$
- 查找：$O(logn)$
- 合并：$O(1)$

## 优先队列

  priority_queue是一个优先队列，优先级高的最先出队，默认最大值优先。内部实现为堆，因此出队和入队的时间复杂度均为$*O*(log*n*)$。可以自定义优先级控制出队顺序，如果是数值，也可以采用加负号的方式实现最小值优先，优先队列不支持删除堆中指定元素，只可以删除堆顶，如果需要删除，可以采用懒操作。需要引入头文件`#include<queue>`。成员函数：

` push(x)`：入队；

` pop()`：出队；

` top()`：取队头元素；

` size()`：返回队中元素个数；

` empty()`：判队空，若为空返回true；

优先队列，其构造及具体实现先不用深究，只需要了解其特性：

`priority_queue<int, vector<int>, cmp >que;`

其中，第一个参数为数据类型，第二个参数为容器类型，第三个参数为比较函数。后两个参数根据需要也可以省略。

优先队列最常用的用法：

```c
priority_queue<int> que; //参数为数据类型，默认优先级（最大值优先）
```

如果要把元素从小到大输出怎么办呢？

有4种方法可以实现优先级控制：

- 使用C++自带的库函数`<functional>`
- 自定义优先级①
- 自定义优先级②
- 自定义优先级③

方法1：使用C++自带的库函数`<functional>`，引用`#include<functional>`

```c
equal_to<Type>   //等于

not_equal_to<Type> //不等于

greater<Type>   //大于

greater_equal<Type> //大于等于

less<Type>    //小于

less_equal<Type>  //小于等于

priority_queue<int,vector<int>, less<int> >que1; //最大值优先 

//注意“>>”会被认为错误，“>>”是右移运算符，用空格号隔开

priority_queue<int,vector<int>, greater<int> >que2;//最小值优先 
```

方法2：自定义优先级① ， 队列元素为数值型

```c
struct cmp1{ 
    bool operator ()(int &a,int &b){ 
        return a<b;//最大值优先，a>b表示最小值优先 
   } 
}; 

//创建优先队列：
priority_queue<int,vector<int>,cmp1>que3;//最大值优先 
```

方法3：自定义优先级 ②，队列元素为结构体型 

```c
struct node1{  
    int x,y;  //结构体中的成员
    bool operator < (const node1 &a) const {  
         return x<a.x;//最大值优先，x>a.x;表示最小值优先 
    }  
};

//创建优先队列：
priority_queue<node1>que5; //使用时要把数据定义为node1类型
```

方法4：自定义优先级 ③，队列元素为结构体型 

```c
struct node3{  
      int x,y;  //结构体中的成员
};  
bool operator <(const node3 &a, const node3 &b) {//在结构体外面定义
      return a.x<b.x; //按成员x最大值优先 
}

//创建优先队列：
priority_queue<node3>que7; //使用时要把数据定义为node3类型
```

**算法时间复杂度分析**

- 入队：$O(logn)$
- 出队：$O(logn)$

## 倍增

任意整数均可被表示成若干个2的次幂项之和。例如整数5，其二进制表示为101，该二进制数从右向左第0、2位均为1，则5=22+20；整数26，其二进制表示为11010，该二进制数从右向左第1、3、4位均为1，则26=24+23+21。也就是说，2的次幂项可被拼成任一需要的值。

 倍增，顾名思义就是成倍增加。若问题的状态空间特别大，则一步步递推的算法复杂度太高，可以通过倍增思想，只考察2的整数次幂位置，快速缩小求解范围，直到找到解。

![image-20220907181756645](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209071817699.png)

## ST表

ST（Sparse Table，稀疏表）算法采用了倍增思想，在$O(nlogn)$时间构造一个二维表之后，可以在$O(1)$时间在线查询$[l, r]$区间的最值，有效解决在线RMQ（Range Minimum/Maximum Query，区间最值查询）问题。

 如何实现呢？设$F[i, j]$表示$[i, i+2^j-1]$区间的最值，区间长度为$2j$。

![image-20220907181820234](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209071818274.png)

 根据倍增思想，长度为$2^j$的区间可被分成两个长度为$2^j-1$的子区间，然后求两个子区间的最值即可。递推公式：$F[i, j]=max(F[i, j-1], F[i+2^{j-1}, j-1])$。

![image-20220907181836251](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209071818314.png)

### ST表创建

若$F[i, j]$表示$[i, i+2^j-1]$区间的最值，区间长度为$2^j$，则$i$和$j$的取值范围是多少呢？

若数组的长度为$n$，最大区间长度$2^k≤n<2^{k+1}$，则$k=⌊log_2n⌋$，比如$n=8$时$k=3$，$n=10$时$k=3$。在程序中，$k=log_2(n)$，也可用通用表达方式$k=log(n)/log(2)$，$log()$表示以$e$为底的自然对数。

例如，有10个元素$a[1..10]={5,3,7,2,12,1,6,4, 8,15}$，创建查询最大值的ST表。

$F[i, j]$表示$[i, i+2^j-1]$区间的最值，区间长度为$2^j$。

![image-20220907182321690](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202209071823748.png)

### ST表查询

若查询$[l,r]$区间的最值，则首先计算$k$值，和前面的计算方法相同，区间长度为$r-l+1，2^k≤r-l+1<2^{k+1}$，因此$k=log_2(r-l+1) $。

若查询区间的长度大于或等于$2^k$且小于$2^{k+1}$，则根据倍增思想，可以将查询区间分为两个查询区间，取两个区间的最值即可。两个区间分别为从$l$向后的$2^k$个数及从$r$向前的$2^k$个数，这两个区间可能有重叠，但对求最值没有影响。

**算法时间复杂度分析**

- ST创建：$O(nlogn)$
- ST查询：$O(1)$

## RMQ

RMQ（区间最值查询）问题有多种解决方法，用线段树和ST解决RMQ问题的对比如下：

- 线段树预处理的时间为$O(nlogn)$，查询的时间为$O(logn)$，支持在线修改；

- ST预处理的时间为$O(nlogn)$，查询的时间为$O(1)$，不支持在线修改。
