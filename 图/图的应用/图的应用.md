## 广度优先搜索

广度优先搜索（Breadth First Search，BFS），又称为宽度优先搜索，是最常见的图搜索方法之一。广度优先搜索是从某个顶点（源点）出发，一次性访问所有未被访问的邻接点，再依次从这些访问过邻接点出发，…，似水中涟漪，似声音传播，一层层地传播开来。

广度优先遍历是按照广度优先搜索的方式对图进行遍历。

![image-20220815173928661](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208151739737.png)

广度优先遍历秘籍：**先被访问的顶点，其邻接点先被访问。**

根据广度优先遍历秘籍，先来先服务，可以借助于队列实现。每个结点访问一次且只访问一次，因此可以设置一个辅助数组：

`visited[*i*]=false`，表示第`i`个顶点未访问；

`visited[*i*]=true`，表示第`i`个顶点已访问。

**算法步骤：**

1. 初始化图中所有顶点未被访问，初始化一个空队列。

2. 从图中的某个顶点*u*出发，访问*u*并标记已访问，将*u*入队；

3. 如果队列非空，则继续执行，否则算法结束；

4. 队头元素*v*出队，依次访问*v*的所有未被访问邻接点，标记已访问并入队。转向步骤3。

**算法分析**

1. 基于邻接矩阵

   访问每个顶点的邻接点需要时间，n个顶点，总时间复杂度为$O(n_2)$，标记数组和队列的空间复杂度为$O(n)$。

2. 基于邻接表

   访问顶点$v_i$的邻接点需要$O(d(v_i))$时间，$d(v_i)$为$v_i$的出度（无向图为度），访问所有邻接点的时间复杂度为`O(e)`，访问时间`O(n)`，总时间复杂度为`O(n+e)`，标记数组和队列的空间复杂度为`O(n)`。

## 深度优先搜索

深度优先搜索（Depth First Search，DFS），是最常见的图搜索方法之一。深度优先搜索沿着一条路径一直走下去，无法行进时，回退到刚刚访问的节点，似不撞南墙不回头，不到黄河不死心。

深度优先遍历是按照深度优先搜索的方式对图进行遍历。

**后被访问的顶点，其邻接点先被访问。**

根据深度优先遍历秘籍，后来先服务，可以借助于栈实现。递归本身就是使用栈实现的，因此使用递归更方便。

每个顶点访问且只访问一次，因此设置一个辅助数组：

`visited[i]=false`，表示第`i`个顶点未访问；

`visited[i]=true`，表示第`i`个顶点已访问。

**算法步骤：**

1. 初始化图中所有顶点未被访问；

2. 从图中的某个顶点`u`出发，访问`u`并标记已访问；

3. 依次检查`u`的所有邻接点`v`，如果`v`未被访问，则从`v`出发深度优先遍历。

**算法分析**

1. 基于邻接矩阵

   访问每个顶点的邻接点需要`O(n)`时间，`n`个顶点，总时间复杂度为$O(n_2)$，递归算法需要栈空间，标记数组和和栈的空间复杂度为`O(n)`。

2. 基于邻接表

   访问顶点$v_i$的邻接点需要$O(d(v_i))$时间，$d(v_i)$为$v_i$的出度（无向图为度），访问所有邻接点的时间复杂度为`O(e)`，访问时间`O(n)`，总时间复杂度为`O(n+e)`，标记数组和和栈的空间复杂度为`O(n)`。

## 连通性问题

### 连通分量

在无向图中，如果从节点$v_i$到节点$v_j$有路径，则称节点$v_i$和节点$v_j$是连通的。如果图中任意两个节点都是连通的，则称图*G*为连通图。

无向图*G*的极大连通子图被称为图*G*的连通分量。极大连通子图是图*G*连通子图，如果再向其中加入一个节点，则该子图不连通。

### 强连通分量

在有向图中，如果图中的任意两个节点从$v_i$到$v_j$都有路径，且从$v_j$到$v_i$也有路径，则称图*G*为强连通图。

有向图*G*的极大强连通子图被称为图*G*的强连通分量。极大强连通子图是图*G*的强连通子图，如果再向其中加入一个节点，则该子图不再是强连通的。

### 桥与割点

如果去掉无向连通图*G*中的一条边*e*，图*G*分裂为两个不相连的子图，那么*e*为图*G*的**桥**或割边。

![image-20220818165019332](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208181650384.png)

如果去掉无向连通图*G*中的一个点*v*及*v*关联的所有边，图*G*分裂为两个或两个以上不相连的子图，那么*v*为图*G*的**割点**。

![image-20220818165037106](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208181650148.png)

**如何求解桥和割点？**

首先引入时间戳和追溯点的概念。

- **时间戳**：`dfn[u]`表示节点`u`的深度优先遍历序号。

- **追溯点**：`low[u]`表示节点`u`或`u`的子孙能通过非父子边追溯到的`dfn`最小值，即回到最早的过去。

初始时，`dfn[u]=low[u]`，如果该节点的邻接点未被访问，则一直进行深度优先遍历。回归更新路径上所有祖先节点的low值，因为子孙能回到的追溯点，其祖先也能回到。

![image-20220818165234991](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208181652031.png)

**桥判定法则**：无向边$ x-y$ 是桥，当且仅当在搜索树上存在` x `的一个子节点` y `时，满足`low[y]>dfn[x]`。

也就是说，若孩子的`low`值比自己的`dfn`值大，则从该节点到这个孩子的边为桥。

![image-20220818165338672](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208181653720.png)

**割点判定法则**：若`x`不是根节点，则`x`是割点，当且仅当在搜索树上存在`x`的一个子节点`y`，满足`low[y]≥dfn[x]`；若`x`是根节点，则`x`是割点，当且仅当在搜索树上至少存在两个子节点，满足该条件。

![image-20220818165443159](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208181654205.png)
