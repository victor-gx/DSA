# 图的应用

## 最短路径问题

### Dijkstra算法

Dijkstra 算法是解决单源最短路径问题的贪心算法，它先求出长度最短的一条路径，再参照该最短路径求出长度次短的一条路径，直到求出源点到其他各个节点的最短路径。

Dijkstra算法基本思想：将节点集合V划分为两部分：集合`S`和` V−S`，其中`S`中的节点到源点的最短路径已经确定，`V−S`中的节点到源点的最短路径待定。

从源点出发只经过S中的节点到达V−S中的节点的路径称为特殊路径。Dijkstra算法的贪心策略是选择最短的特殊路径长度`dist[t]`，并将节点t加入到集合S中，同时借助t更新数组`dist[]`。一旦S包含了所有节点，`dist[]`就是从源点到其他节点的最短路径长度。

![image-20220820145426723](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208201454775.png)

**算法设计**

1. 数据结构。邻接矩阵`G[][]`存储图，`dist[i]`记录从源点到节点`i`的最短路径长度，`p[i]`记录最短路径上节点`i`的直接前驱。如果`flag[i]`等于`true`，说明节点`i`已加入集合`S`，否则`i`属于集合`V-S`。
2. 初始化。假设`u`为源点，令集合`S={u}`，对`V−S`集合中的节点`i`，初始化`dist[i]=G[u][i]`，如果源点`u`到节点`i`有边相连，初始化`p[i]=u`，否则`p[i]= −1`。
3. 找最小。按照贪心策略来查找`V−S`集合中`dist[]`最小的节点`t`，`t`就是`V−S`集合中距离源点`u`最近的节点。将节点`t`加入集合`S`中。
4. 松弛操作。对`V−S`集合中所有节点`j`，考察是否可以借助`t`得到更短的路径。如果源点`u`经过`t`到`j`的路径更短，`dist[j]>dist[t]+G[t][j]`，则更新`dist[j]=dist[t]+G[t][j]`，即松弛操作，并记录`j`的直接前驱为`t`，即`p[j]=t`。
5. 重复执行(3)～(4)，直到`V−S`为空。

**算法分析**

- 时间复杂度：找最小值和松弛操作本身各执行`n`次，需要重复`n-1`次，总执行次数均为$n^2$，时间复杂度为$O(n^2)$。
- 空间复杂度：包含数组`flag[]`、`p[]`，空间复杂度为$O(n)$。

### Floyd算法

Dijkstra算法用于求从源点到其他各个节点的最短路径。如果求解任意两个节点之间的最短路径，则需要以每个节点为源点，重复调用n次Dijkstra算法。其实完全没必要这么麻烦，Floyd算法可用于求解任意两个节点间的最短路径。Floyd算法又被称为插点法，其算法核心是在节点`i`与节点`j`之间插入节点`k`，看看是否可以缩短节点`i`与节点`j`之间的距离（松弛操作）。

 **算法设计**

1. 数据结构。邻接矩阵`G[][]`存储图，`dist[i][j]`记录从节点`i`到节点`j`的最短路径长度，`p[i][j]`记录节点`i`到节点`j`的最短路径上节点`j`的直接前驱。
2. 初始化。 `dist[i][j]=G[i][j]`，如果节点`i`到节点`j`有边相连， `p[i][j]=i`，否则`p[i][j]=−1`。
3. 插点。其实就是在节点`i`、`j`之间插入节点`k`，看是否可以缩短节点`i`、`j`之间的距离（松弛操作）。如果` dist[i][j]>dist[i][k]+dist[k][j]`，则`dist[i][j]=dist[i][k]+dist[k][j]`，并记录节点`j`的前驱，`p[i][j]=p[k][j]`。

**算法分析**

- 时间复杂度：三层`for`循环，时间复杂度为$O(n^3)$。
- 空间复杂度：数组`dist[][]`、`p[][]`，空间复杂度为$O(n^2)$。

### Bellman-Ford算法

Bellman-Ford算法用于求解单源最短路径问题，由理查德·贝尔曼和莱斯特·福特提出。该算法的优点是边的权值可以为负数、实现简单，缺点是时间复杂度过高。但是，对该算法可以进行若干种优化，以提高效率。

Bellman-Ford算法与Dijkstra算法类似，都以松弛操作为基础。Dijkstra算法以贪心法选取未被处理的具有最小权值的节点，然后对其邻接点进行松弛操作。Bellman-Ford算法对所有边进行松弛操作，共`n-1`次，因为负环可以无限制地减少最短路径长度，所以如果第`n`次操作仍可松弛，则一定存在负环。

 **算法设计**

1. 数据结构。因为需要利用边进行松弛，因此采用边集数组存储。每条边都有三个域：两个端点`a`、`b`和边权`w`。
2. 松弛操作。对所有的边`j(a,b,w)`，如果`dist[e[j].b]>dist[e[j].a]+e[j].w`，则`dist[e[j].b]=dist[e[j].a]+e[j].w`。`dist[v]`表示从源点到节点`v`的最短路径长度。
3. 重复松弛操作`n-1`次。
4. 再执行一次，如果仍然可以松弛，则说明有负环。

**算法分析**

- 时间复杂度：算法中对每条边进行松弛操作，重复`n-1`次，时间复杂度为$O(nm)$。
- 空间复杂度：包含数组`e[]`、`dist[]`，空间复杂度为$O(n+m)$。

**算法优化1**

提前退出循环。在实际操作中，Bellman-Ford算法经常会在未达到`n-1`次时就求解完毕，可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环。通过上段代码中的`if(!flag)`就可以提前退出循环。

**算法优化2**

队列优化。松弛操作必定只会发生在最短路径松弛过的前驱节点上，用一个队列记录松弛过的节点，可以避免冗余计算。这就是队列优化的Bellman-Ford算法，又被称为SPFA算法。

### SPFA算法

SPFA（Shortest Path Faster Algorithm）算法是Bellman-Ford算法的队列优化算法，通常用于求解含负权边的单源最短路径，以及判负环。在最坏情况下，SPFA算法的时间复杂度和Bellman-Ford算法相同，为$O(nm)$；但在稀疏图上运行效率较高，为$O(km)$，其中`k`是一个较小的常数。

 **算法设计**

1. 数据结构。链式前向星存储图，`dist[i]`记录从源点到节点`i`的最短路径长度, `vis[i]`标记节点`i`是否在队列中，`sum[i]`记录节点`i`入队次数。
2. 创建一个队列，源点`u`入队，标记`u`在队列中，`u`的入队次数加`1`。
3. 松弛操作。取出队头`x`，标记`x`不在队列中。考察`x`的所有出边`i(x,v,w)`，如果`dist[v]>dist[x]+e[i].w`，则`dist[v]=dist[x]+e[i].w`。如果节点`v`不在队列中，如果`v`的入队次数加`1`后大于或等于`n`，则说明有负环，退出；否则`v`入队，标记`v`在队列中。
4. 重复松弛操作，直到队列为空。

**算法分析**

- 时间复杂度：最坏情况下的时间复杂度为$O(nm)$，对于稀疏图的时间复杂度为$O(km)$，其中`k`是一个较小的常数。
- 空间复杂度：包含数组`e[]`、`dist[]`，空间复杂度为$O(n+m)$。

**算法优化**

SPFA算法有两个优化策略：SLF和LLL。

- SLF（Small Label First）策略：如果待入队的节点是`j`，队首元素为节点`i`，若`dist[j]<dist[i]`，则将`j`插入队首，否则插入队尾。

- LLL（Large Label Last）策略：设队首元素为节点`i`，队列中所有`dist[]`的平均值为`x`，若`dist[i]>x`，则将节点`i`插入队尾，查找下一元素，直到找到某一节点`i`满足`dist[i]<=x`，将节点`i`出队，进行松弛操作。

SLF和LLL在随机数据上表现优秀，但是在正权图上的最坏情况为$O(nm)$，在负权图上的最坏情况为达到指数级复杂度。

### 最短路径算法比较分析

- **Dijkstra算法**：$O(n^2)$，$O(mlogn)$
- **Floyd算法**：$O(n^3)$
- **Bellman-Ford算法**：$O(nm)$
- **SPFA算法**：$O(km)$，$O(nm)$

## 最小生成树

如何设计网络电缆布线，将各个单位连通起来，并使费用最少呢？

对于*n*个顶点的连通图，只需*n*−1条边就可以使这个图连通，*n*−1条边要想保证图连通，就必须不含回路，所以只需要找出*n* −1条权值最小且无回路的边即可。

- **子图：**从原图中选一些顶点和边组成的图，称为原图的子图。
- **生成子图：**从原图中选**所有顶点**和一些边组成的图，称为原图的生成子图。
- **生成树：**如果生成子图恰好是一棵树，则称为生成树。
- **最小生成树：**权值之和最小的生成树，则称为最小生成树。

找出n −1条权值最小的边很容易，那么怎么保证无回路呢？如果在一个图中深度搜索或广度搜索有没有回路，是一件繁重的工作。有一个很好的办法——**集合避圈法**。

### Prim算法

把已经在生成树中的节点看作一个集合，剩下节点看作另一个集合，从连接两个集合的边中选择一条权值最小的边。

![image-20220825150110345](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208251501430.png)

直观地看图很容易找出`U`集合到`V−U`集合的边中哪条边是最小的，但是程序中如果穷举这些边，再找最小值就太麻烦了，那怎么办呢？

可以设置两个数组巧妙地解决这个问题：

`closest[j]`：表示`V−U`中的顶点`j`到集合`U`中的最邻近点；

`lowcost[j]`：表示`V−U`中的顶点`j`到集合`U`中的最邻近点的边值，即边（`j`，`closest[j]`）的权值。

![image-20220825150133672](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208251501743.png)

**算法设计**

1）初始化。令集合$U={u_0}$，$u_0∈V$，并初始化数组`s[]`、`closest[]`、`lowcost[]`。

2）在`V−U`集合中找`lowcost[]`值最小的顶点`t`，即`lowcost[t]=min{lowcost[j]|j∈V−U}`，满足该公式的顶点`t`就是集合`V−U`中连接集合`U`的最邻近点。

3）将顶点`t`加入集合`U`。

4）如果集合`V−U`为空，算法结束，否则，转第5步。

5）对集合`V−U`中的所有顶点`j`，更新其`lowcost[]`和`closest[]`，转第2步。 更新：

```c
if(C[t][j]<lowcost[j]) {

  lowcost[j]=C[t][j];

  closest[j]=t; 

}
```

**算法分析**

- 时间复杂度：两层`for`循环，时间复杂度为$O(n^2) $。
- 空间复杂度：辅助数组`closest[]`、`lowcost[]`、`s[]`，空间复杂度为$O(n)$。
