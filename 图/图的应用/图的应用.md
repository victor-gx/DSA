# 图的应用

## 最短路径问题

### Dijkstra算法

Dijkstra 算法是解决单源最短路径问题的贪心算法，它先求出长度最短的一条路径，再参照该最短路径求出长度次短的一条路径，直到求出源点到其他各个节点的最短路径。

Dijkstra算法基本思想：将节点集合V划分为两部分：集合`S`和` V−S`，其中`S`中的节点到源点的最短路径已经确定，`V−S`中的节点到源点的最短路径待定。

从源点出发只经过S中的节点到达V−S中的节点的路径称为特殊路径。Dijkstra算法的贪心策略是选择最短的特殊路径长度`dist[t]`，并将节点t加入到集合S中，同时借助t更新数组`dist[]`。一旦S包含了所有节点，`dist[]`就是从源点到其他节点的最短路径长度。

![image-20220820145426723](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208201454775.png)

**算法设计**

1. 数据结构。邻接矩阵`G[][]`存储图，`dist[i]`记录从源点到节点`i`的最短路径长度，`p[i]`记录最短路径上节点`i`的直接前驱。如果`flag[i]`等于`true`，说明节点`i`已加入集合`S`，否则`i`属于集合`V-S`。
2. 初始化。假设`u`为源点，令集合`S={u}`，对`V−S`集合中的节点`i`，初始化`dist[i]=G[u][i]`，如果源点`u`到节点`i`有边相连，初始化`p[i]=u`，否则`p[i]= −1`。
3. 找最小。按照贪心策略来查找`V−S`集合中`dist[]`最小的节点`t`，`t`就是`V−S`集合中距离源点`u`最近的节点。将节点`t`加入集合`S`中。
4. 松弛操作。对`V−S`集合中所有节点`j`，考察是否可以借助`t`得到更短的路径。如果源点`u`经过`t`到`j`的路径更短，`dist[j]>dist[t]+G[t][j]`，则更新`dist[j]=dist[t]+G[t][j]`，即松弛操作，并记录`j`的直接前驱为`t`，即`p[j]=t`。
5. 重复执行(3)～(4)，直到`V−S`为空。

**算法分析**

- 时间复杂度：找最小值和松弛操作本身各执行`n`次，需要重复`n-1`次，总执行次数均为$n^2$，时间复杂度为$O(n^2)$。
- 空间复杂度：包含数组`flag[]`、`p[]`，空间复杂度为$O(n)$。

### Floyd算法

Dijkstra算法用于求从源点到其他各个节点的最短路径。如果求解任意两个节点之间的最短路径，则需要以每个节点为源点，重复调用n次Dijkstra算法。其实完全没必要这么麻烦，Floyd算法可用于求解任意两个节点间的最短路径。Floyd算法又被称为插点法，其算法核心是在节点`i`与节点`j`之间插入节点`k`，看看是否可以缩短节点`i`与节点`j`之间的距离（松弛操作）。

 **算法设计**

1. 数据结构。邻接矩阵`G[][]`存储图，`dist[i][j]`记录从节点`i`到节点`j`的最短路径长度，`p[i][j]`记录节点`i`到节点`j`的最短路径上节点`j`的直接前驱。
2. 初始化。 `dist[i][j]=G[i][j]`，如果节点`i`到节点`j`有边相连， `p[i][j]=i`，否则`p[i][j]=−1`。
3. 插点。其实就是在节点`i`、`j`之间插入节点`k`，看是否可以缩短节点`i`、`j`之间的距离（松弛操作）。如果` dist[i][j]>dist[i][k]+dist[k][j]`，则`dist[i][j]=dist[i][k]+dist[k][j]`，并记录节点`j`的前驱，`p[i][j]=p[k][j]`。

**算法分析**

- 时间复杂度：三层`for`循环，时间复杂度为$O(n^3)$。
- 空间复杂度：数组`dist[][]`、`p[][]`，空间复杂度为$O(n^2)$。

### Bellman-Ford算法

Bellman-Ford算法用于求解单源最短路径问题，由理查德·贝尔曼和莱斯特·福特提出。该算法的优点是边的权值可以为负数、实现简单，缺点是时间复杂度过高。但是，对该算法可以进行若干种优化，以提高效率。

Bellman-Ford算法与Dijkstra算法类似，都以松弛操作为基础。Dijkstra算法以贪心法选取未被处理的具有最小权值的节点，然后对其邻接点进行松弛操作。Bellman-Ford算法对所有边进行松弛操作，共`n-1`次，因为负环可以无限制地减少最短路径长度，所以如果第`n`次操作仍可松弛，则一定存在负环。

 **算法设计**

1. 数据结构。因为需要利用边进行松弛，因此采用边集数组存储。每条边都有三个域：两个端点`a`、`b`和边权`w`。
2. 松弛操作。对所有的边`j(a,b,w)`，如果`dist[e[j].b]>dist[e[j].a]+e[j].w`，则`dist[e[j].b]=dist[e[j].a]+e[j].w`。`dist[v]`表示从源点到节点`v`的最短路径长度。
3. 重复松弛操作`n-1`次。
4. 再执行一次，如果仍然可以松弛，则说明有负环。

**算法分析**

- 时间复杂度：算法中对每条边进行松弛操作，重复`n-1`次，时间复杂度为$O(nm)$。
- 空间复杂度：包含数组`e[]`、`dist[]`，空间复杂度为$O(n+m)$。

**算法优化1**

提前退出循环。在实际操作中，Bellman-Ford算法经常会在未达到`n-1`次时就求解完毕，可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环。通过上段代码中的`if(!flag)`就可以提前退出循环。

**算法优化2**

队列优化。松弛操作必定只会发生在最短路径松弛过的前驱节点上，用一个队列记录松弛过的节点，可以避免冗余计算。这就是队列优化的Bellman-Ford算法，又被称为SPFA算法。
