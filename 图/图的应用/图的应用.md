# 图的应用

## 最短路径问题

### Dijkstra算法

Dijkstra 算法是解决单源最短路径问题的贪心算法，它先求出长度最短的一条路径，再参照该最短路径求出长度次短的一条路径，直到求出源点到其他各个节点的最短路径。

Dijkstra算法基本思想：将节点集合V划分为两部分：集合`S`和` V−S`，其中`S`中的节点到源点的最短路径已经确定，`V−S`中的节点到源点的最短路径待定。

从源点出发只经过S中的节点到达V−S中的节点的路径称为特殊路径。Dijkstra算法的贪心策略是选择最短的特殊路径长度`dist[t]`，并将节点t加入到集合S中，同时借助t更新数组`dist[]`。一旦S包含了所有节点，`dist[]`就是从源点到其他节点的最短路径长度。

![image-20220820145426723](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208201454775.png)

**算法设计**

1. 数据结构。邻接矩阵`G[][]`存储图，`dist[i]`记录从源点到节点`i`的最短路径长度，`p[i]`记录最短路径上节点`i`的直接前驱。如果`flag[i]`等于`true`，说明节点`i`已加入集合`S`，否则`i`属于集合`V-S`。
2. 初始化。假设`u`为源点，令集合`S={u}`，对`V−S`集合中的节点`i`，初始化`dist[i]=G[u][i]`，如果源点`u`到节点`i`有边相连，初始化`p[i]=u`，否则`p[i]= −1`。
3. 找最小。按照贪心策略来查找`V−S`集合中`dist[]`最小的节点`t`，`t`就是`V−S`集合中距离源点`u`最近的节点。将节点`t`加入集合`S`中。
4. 松弛操作。对`V−S`集合中所有节点`j`，考察是否可以借助`t`得到更短的路径。如果源点`u`经过`t`到`j`的路径更短，`dist[j]>dist[t]+G[t][j]`，则更新`dist[j]=dist[t]+G[t][j]`，即松弛操作，并记录`j`的直接前驱为`t`，即`p[j]=t`。
5. 重复执行(3)～(4)，直到`V−S`为空。

**算法分析**

（1）时间复杂度：找最小值和松弛操作本身各执行`n`次，需要重复`n-1`次，总执行次数均为$n^2$，时间复杂度为$O(n^2)$。

（2）空间复杂度：包含数组`flag[]`、`p[]`，空间复杂度为$O(n)$。





