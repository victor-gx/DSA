# 图的应用

## 最短路径问题

### Dijkstra算法

Dijkstra 算法是解决单源最短路径问题的贪心算法，它先求出长度最短的一条路径，再参照该最短路径求出长度次短的一条路径，直到求出源点到其他各个节点的最短路径。

Dijkstra算法基本思想：将节点集合V划分为两部分：集合`S`和` V−S`，其中`S`中的节点到源点的最短路径已经确定，`V−S`中的节点到源点的最短路径待定。

从源点出发只经过S中的节点到达V−S中的节点的路径称为特殊路径。Dijkstra算法的贪心策略是选择最短的特殊路径长度`dist[t]`，并将节点t加入到集合S中，同时借助t更新数组`dist[]`。一旦S包含了所有节点，`dist[]`就是从源点到其他节点的最短路径长度。

![image-20220820145426723](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208201454775.png)

**算法设计**

1. 数据结构。邻接矩阵`G[][]`存储图，`dist[i]`记录从源点到节点`i`的最短路径长度，`p[i]`记录最短路径上节点`i`的直接前驱。如果`flag[i]`等于`true`，说明节点`i`已加入集合`S`，否则`i`属于集合`V-S`。
2. 初始化。假设`u`为源点，令集合`S={u}`，对`V−S`集合中的节点`i`，初始化`dist[i]=G[u][i]`，如果源点`u`到节点`i`有边相连，初始化`p[i]=u`，否则`p[i]= −1`。
3. 找最小。按照贪心策略来查找`V−S`集合中`dist[]`最小的节点`t`，`t`就是`V−S`集合中距离源点`u`最近的节点。将节点`t`加入集合`S`中。
4. 松弛操作。对`V−S`集合中所有节点`j`，考察是否可以借助`t`得到更短的路径。如果源点`u`经过`t`到`j`的路径更短，`dist[j]>dist[t]+G[t][j]`，则更新`dist[j]=dist[t]+G[t][j]`，即松弛操作，并记录`j`的直接前驱为`t`，即`p[j]=t`。
5. 重复执行(3)～(4)，直到`V−S`为空。

**算法分析**

- 时间复杂度：找最小值和松弛操作本身各执行`n`次，需要重复`n-1`次，总执行次数均为$n^2$，时间复杂度为$O(n^2)$。
- 空间复杂度：包含数组`flag[]`、`p[]`，空间复杂度为$O(n)$。

### Floyd算法

Dijkstra算法用于求从源点到其他各个节点的最短路径。如果求解任意两个节点之间的最短路径，则需要以每个节点为源点，重复调用n次Dijkstra算法。其实完全没必要这么麻烦，Floyd算法可用于求解任意两个节点间的最短路径。Floyd算法又被称为插点法，其算法核心是在节点`i`与节点`j`之间插入节点`k`，看看是否可以缩短节点`i`与节点`j`之间的距离（松弛操作）。

 **算法设计**

1. 数据结构。邻接矩阵`G[][]`存储图，`dist[i][j]`记录从节点`i`到节点`j`的最短路径长度，`p[i][j]`记录节点`i`到节点`j`的最短路径上节点`j`的直接前驱。
2. 初始化。 `dist[i][j]=G[i][j]`，如果节点`i`到节点`j`有边相连， `p[i][j]=i`，否则`p[i][j]=−1`。
3. 插点。其实就是在节点`i`、`j`之间插入节点`k`，看是否可以缩短节点`i`、`j`之间的距离（松弛操作）。如果` dist[i][j]>dist[i][k]+dist[k][j]`，则`dist[i][j]=dist[i][k]+dist[k][j]`，并记录节点`j`的前驱，`p[i][j]=p[k][j]`。

**算法分析**

- 时间复杂度：三层`for`循环，时间复杂度为$O(n^3)$。
- 空间复杂度：数组`dist[][]`、`p[][]`，空间复杂度为$O(n^2)$。

### Bellman-Ford算法

Bellman-Ford算法用于求解单源最短路径问题，由理查德·贝尔曼和莱斯特·福特提出。该算法的优点是边的权值可以为负数、实现简单，缺点是时间复杂度过高。但是，对该算法可以进行若干种优化，以提高效率。

Bellman-Ford算法与Dijkstra算法类似，都以松弛操作为基础。Dijkstra算法以贪心法选取未被处理的具有最小权值的节点，然后对其邻接点进行松弛操作。Bellman-Ford算法对所有边进行松弛操作，共`n-1`次，因为负环可以无限制地减少最短路径长度，所以如果第`n`次操作仍可松弛，则一定存在负环。

 **算法设计**

1. 数据结构。因为需要利用边进行松弛，因此采用边集数组存储。每条边都有三个域：两个端点`a`、`b`和边权`w`。
2. 松弛操作。对所有的边`j(a,b,w)`，如果`dist[e[j].b]>dist[e[j].a]+e[j].w`，则`dist[e[j].b]=dist[e[j].a]+e[j].w`。`dist[v]`表示从源点到节点`v`的最短路径长度。
3. 重复松弛操作`n-1`次。
4. 再执行一次，如果仍然可以松弛，则说明有负环。

**算法分析**

- 时间复杂度：算法中对每条边进行松弛操作，重复`n-1`次，时间复杂度为$O(nm)$。
- 空间复杂度：包含数组`e[]`、`dist[]`，空间复杂度为$O(n+m)$。

**算法优化1**

提前退出循环。在实际操作中，Bellman-Ford算法经常会在未达到`n-1`次时就求解完毕，可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环。通过上段代码中的`if(!flag)`就可以提前退出循环。

**算法优化2**

队列优化。松弛操作必定只会发生在最短路径松弛过的前驱节点上，用一个队列记录松弛过的节点，可以避免冗余计算。这就是队列优化的Bellman-Ford算法，又被称为SPFA算法。

### SPFA算法

SPFA（Shortest Path Faster Algorithm）算法是Bellman-Ford算法的队列优化算法，通常用于求解含负权边的单源最短路径，以及判负环。在最坏情况下，SPFA算法的时间复杂度和Bellman-Ford算法相同，为$O(nm)$；但在稀疏图上运行效率较高，为$O(km)$，其中`k`是一个较小的常数。

 **算法设计**

1. 数据结构。链式前向星存储图，`dist[i]`记录从源点到节点`i`的最短路径长度, `vis[i]`标记节点`i`是否在队列中，`sum[i]`记录节点`i`入队次数。
2. 创建一个队列，源点`u`入队，标记`u`在队列中，`u`的入队次数加`1`。
3. 松弛操作。取出队头`x`，标记`x`不在队列中。考察`x`的所有出边`i(x,v,w)`，如果`dist[v]>dist[x]+e[i].w`，则`dist[v]=dist[x]+e[i].w`。如果节点`v`不在队列中，如果`v`的入队次数加`1`后大于或等于`n`，则说明有负环，退出；否则`v`入队，标记`v`在队列中。
4. 重复松弛操作，直到队列为空。

**算法分析**

- 时间复杂度：最坏情况下的时间复杂度为$O(nm)$，对于稀疏图的时间复杂度为$O(km)$，其中`k`是一个较小的常数。
- 空间复杂度：包含数组`e[]`、`dist[]`，空间复杂度为$O(n+m)$。

**算法优化**

SPFA算法有两个优化策略：SLF和LLL。

- SLF（Small Label First）策略：如果待入队的节点是`j`，队首元素为节点`i`，若`dist[j]<dist[i]`，则将`j`插入队首，否则插入队尾。

- LLL（Large Label Last）策略：设队首元素为节点`i`，队列中所有`dist[]`的平均值为`x`，若`dist[i]>x`，则将节点`i`插入队尾，查找下一元素，直到找到某一节点`i`满足`dist[i]<=x`，将节点`i`出队，进行松弛操作。

SLF和LLL在随机数据上表现优秀，但是在正权图上的最坏情况为$O(nm)$，在负权图上的最坏情况为达到指数级复杂度。

### 最短路径算法比较分析

- **Dijkstra算法**：$O(n^2)$，$O(mlogn)$
- **Floyd算法**：$O(n^3)$
- **Bellman-Ford算法**：$O(nm)$
- **SPFA算法**：$O(km)$，$O(nm)$

## 最小生成树

如何设计网络电缆布线，将各个单位连通起来，并使费用最少呢？

对于*n*个顶点的连通图，只需*n*−1条边就可以使这个图连通，*n*−1条边要想保证图连通，就必须不含回路，所以只需要找出*n* −1条权值最小且无回路的边即可。

- **子图：**从原图中选一些顶点和边组成的图，称为原图的子图。
- **生成子图：**从原图中选**所有顶点**和一些边组成的图，称为原图的生成子图。
- **生成树：**如果生成子图恰好是一棵树，则称为生成树。
- **最小生成树：**权值之和最小的生成树，则称为最小生成树。

找出n −1条权值最小的边很容易，那么怎么保证无回路呢？如果在一个图中深度搜索或广度搜索有没有回路，是一件繁重的工作。有一个很好的办法——**集合避圈法**。

### Prim算法

把已经在生成树中的节点看作一个集合，剩下节点看作另一个集合，从连接两个集合的边中选择一条权值最小的边。

![image-20220825150110345](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208251501430.png)

直观地看图很容易找出`U`集合到`V−U`集合的边中哪条边是最小的，但是程序中如果穷举这些边，再找最小值就太麻烦了，那怎么办呢？

可以设置两个数组巧妙地解决这个问题：

`closest[j]`：表示`V−U`中的顶点`j`到集合`U`中的最邻近点；

`lowcost[j]`：表示`V−U`中的顶点`j`到集合`U`中的最邻近点的边值，即边（`j`，`closest[j]`）的权值。

![image-20220825150133672](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208251501743.png)

**算法设计**

1）初始化。令集合$U={u_0}$，$u_0∈V$，并初始化数组`s[]`、`closest[]`、`lowcost[]`。

2）在`V−U`集合中找`lowcost[]`值最小的顶点`t`，即`lowcost[t]=min{lowcost[j]|j∈V−U}`，满足该公式的顶点`t`就是集合`V−U`中连接集合`U`的最邻近点。

3）将顶点`t`加入集合`U`。

4）如果集合`V−U`为空，算法结束，否则，转第5步。

5）对集合`V−U`中的所有顶点`j`，更新其`lowcost[]`和`closest[]`，转第2步。 更新：

```c
if(C[t][j]<lowcost[j]) {

  lowcost[j]=C[t][j];

  closest[j]=t; 

}
```

**算法分析**

- 时间复杂度：两层`for`循环，时间复杂度为$O(n^2) $。
- 空间复杂度：辅助数组`closest[]`、`lowcost[]`、`s[]`，空间复杂度为$O(n)$。

### Kruskal算法

Kruskal算法将`n`个顶点看成是`n`个孤立的连通分支，首先将所有的边按权值从小到大排序，然后做贪心选择：

在边集`E`中选取权值最小的边`(i, j)`，如果将边`(i, j)`加入集合`TE`中不产生回路（圈），则将边`(i, j)`加入边集`TE`中；否则继续选择下一条最短边。

怎样判断加入某条边后`T`中会不会出现回路呢？

Kruskal用了一个非常聪明的方法，即**集合避圈法**：

如果待选择边的起点和终点都在`T`的集合中，就可以判定形成回路（圈）。待选择边的两个端点不能属于同一集合。

**算法设计**

1. 初始化。将图`G`的边集`E`中的所有边按权值从小到大排序，边集`TE={ }`，每个顶点初始化一个集合号。
2. 在`E`中寻找权值最小的边`(i, j)`。
3. 如果顶点`i`和`j`位于两个不同连通分支，则将边`(i, j)`加入边集`TE`，并将两个连通分支进行合并。
4. 将边`(i, j)`从集合`E`中删去，即`E=E−{(i, j)}`。
5. 如果选取边数小于`n−1`，转步骤2；否则，算法结束。

**算法分析**

- 时间复杂度：边排序为$O(mlogm)$，合并为$O(n^2)$。
- 空间复杂度：辅助数组`nodeset[]`，空间复杂度为$O(n)$。

**算法优化**

- 时间复杂度：边排序为$O(mlogm)$，合并为$O(nlogn) $。
- 空间复杂度：空间复杂度为$O(n)$。

## 拓扑排序

### AOV网

一个无环的有向图称为**有向无环图**（DAG）。有向无环图是描述一个工程、计划、生产、系统等流程的有效工具。一个大工程可分为若干个子工程（活动），活动之间通常有一定的约束，例如先做什么活动、后做什么活动。

用顶点表示活动，用弧表示活动之间的优先关系的有向图，称为顶点表示活动的网（Activity On Vertex Network），简称**AOV网**。

在AOV网中，若从顶点`i`到顶点`j`之间存在一条有向路径，称顶点`i`是顶点`j`的**前驱**，或者称顶点`j`是顶点`i`的**后继**。若`<i，j>`是图中的弧，则称顶点`i`是顶点`j`的**直接前驱**，顶点`j`是顶点`i`的**直接后驱**。

AOV网中的弧表示活动之间存在的制约关系。例如，计算机专业的学生必须完成一系列规定的基础课和专业课才能毕业。学生按照怎样的顺序来学习这些课程呢？

![image-20220827144347496](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208271444154.png)

### 拓扑排序

拓扑排序是指将AOV网中的顶点排成一个线性序列，该序列必须满足：

若从顶点`i`到顶点`j`有一条路径，则该序列中顶点`i`一定在顶点`j`之前。

>  注意：拓扑排序并不是唯一的。

 **算法设计**

1. 求出各顶点的入度，存入数组`in[]`中，并将入度为`0`的顶点入栈`S`。
2. 如果栈不空，则重复执行以下操作：
   - 栈顶元素`i`出栈，并保存到拓扑序列数组`topo[]`中；
   - 顶点`i`的所有邻接点入度减`1`，如果减`1`后入度为`0`，则入栈。

3. 如果输出的顶点数小于AOV网中的顶点数，则说明网中有环，否则输出拓扑序列。

**算法分析**

- 时间复杂度：访问每个节点的邻接点，时间复杂度为$O(e) $。`n`为节点数，`e`为边数。
- 空间复杂度：辅助数组`indegree[]`、`topo[]`、栈`S`，空间复杂度为$O(n)$。

## 关键路径

**AOV网**可以反映活动之间的先后制约关系，但在实际工程中，有时活动不仅有先后顺序，还有持续时间，即必须经过多长时间该活动才可以完成。这时需要另外一种边表示活动的网络（Activity On Edge Network），简称**AOE网**。AOE网是一个带权的有向无环图，顶点表示事件，弧表示活动，弧上的权值表示活动持续的时间。

![image-20220828144631422](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208281446531.png)

在实际工程应用中，通常需要解决两个问题：

1. 估算完成整个工程至少需要多少时间；
2. 判断哪些活动是关键活动，即如果该活动耽搁会影响整个工程进度。

在AOE网中，从源点到汇点的带权路径长度最大的路径为**关键路径**，关键路径上的活动为**关键活动**。

如何确定关键路径呢？

首先要清楚4个问题：

- 事件的最早发生时间
- 事件的最迟发生时间
- 活动的最早发生时间
- 活动的最迟发生时间

1. 事件$V_i$的最早发生时间`ve[i]`

   事件$V_i$的最早发生时间是从源点到$V_i$的最大路径长度。

   $V_i$的最早发生时间考查入边，取弧尾`ve`+`入边权值的最大值`。

![image-20220828144834276](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208281448379.png)

2. 事件$V_i$的最迟发生时间`vl[i]`

   $V_i$的最迟发生时间考查出边，取弧头`vl`−`出边权值的最小值`。

![image-20220828144947246](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208281449308.png)

3. 活动$a_i=<V_j, V_k>$的最早发生时间`e[i]`

   $*a_i*$的最早发生时间为其弧尾的最早发生时间。

![image-20220828145041363](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208281450412.png)

4. 活动$a_i=<V_j, V_k>$的最迟发生时间`l[i]`

   即活动$*a_i*$的最迟发生时间等于弧头的最迟发生时间减去边值。

![image-20220828145152254](https://victor-gx.oss-cn-beijing.aliyuncs.com/img/2022/DSA/202208281451306.png)

**求解秘籍：**

1. 事件$V_i$的最早发生时间`ve[i]`：考查入边，弧尾`ve`+`入边最大值`。
2. 事件$V_i$的最迟发生时间`vl[i]`：考查出边，弧头`vl`−`出边最小值`。
3. 活动$a_i$的最早发生时间`e[i]`：弧尾的最早发生时间。
4. 活动$a_i$的最迟发生时间`l[i]`：弧头的最迟发生时间减去边值。

**算法设计**

1. 利用拓扑排序算法，将拓扑排序结果保存在`topo[]`数组中。
2. 将每个事件的最早发生时间初始化为0，即`ve[i]=0`。
3. 根据拓扑顺序从前向后，求每个事件的最早发生时间。
4. 按照逆拓扑顺序从后向前，求解每个事件的最迟发生时间。
5. 判断活动是否为关键活动。计算活动$<V_i, V_j>$的最早和最迟发生时间，如果两者相等，则活动$<V_i, V_j>$为关键活动。

**算法分析**

- 时间复杂度：时间复杂度为$O(n+e)$ 。
- 空间复杂度：空间复杂度为$O(n+e)$。
